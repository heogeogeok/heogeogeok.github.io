---
layout: default
title: 2.2. Indexes
parent: 2. Memory Management
nav_order: 5
---
<div style="text-align: center;">
2.2. INDEXES
</div>
{: .fs-10 }

MongoDB offers extensive support for indexing documents, a crucial feature when dealing with large collections containing tens of thousands of documents. Without an index, MongoDB would need to scan each document individually to find the data you needâ€”similar to a librarian searching every book in a library to find the one you're looking for. In contrast, an indexing system allows MongoDB to quickly locate the relevant documents, much like how a librarian uses the Dewey Decimal system to locate books.

### Built-in Indexing on `_id` Key

- **Automatic Indexing**:
  All documents in MongoDB are automatically indexed on the `_id` key. This key is special because it cannot be deleted, and the index ensures that each value is unique. This guarantees that every document is uniquely identifiable, something that traditional RDBMS systems don't always ensure.

### Creating Custom Indexes

- **Uniqueness Enforcement**:When creating your own indexes, you can decide whether to enforce uniqueness. By default, MongoDB will return an error if you try to create a unique index on a key that has duplicate values. However, there are many scenarios where allowing duplicates in an index is beneficial. For instance, if your application frequently searches by last name, it makes sense to create an index on the `lastname` key, even though duplicates are likely.
- **Indexing Embedded Documents**:MongoDB also supports indexing embedded documents. For example, if you store addresses in an `address` field, you can create an index on the ZIP or postal code. This enables you to quickly retrieve documents based on postal codes.
- **Composite Indexes**:
  MongoDB allows you to create composite indexes, which use two or more keys to build a single index. For example, you could create an index that combines both `lastname` and `firstname` fields. This would make searching for a full name very efficient, as MongoDB can rapidly narrow down the results.

### Data Modeling and Indexing

- **Conceptual Mapping with RDBMS**:In MongoDB, there is a conceptual mapping between traditional RDBMS data models and MongoDB's approach. A MongoDB collection corresponds to a table in RDBMS, a BSON document is similar to a row, and key-value pairs in a document are analogous to fields in a row.
- **Primary Index on `_id`**:When a new document is created, MongoDB automatically assigns an `_id` as the primary key, with its value increasing monotonically. A primary index is also automatically built based on the `_id` key.
- **Secondary Indexes**:MongoDB supports secondary indexes, and each time a new secondary index is created, a corresponding index file is generated in the associated directory. However, when deciding to add a secondary index, you must carefully consider the trade-off between read and write performance. For workloads with frequent updates, more secondary indexes can slow down the system, as each update to collection pages requires corresponding updates to the secondary indexes.
- **Storage Structure**:
  MongoDB's WiredTiger storage engine uses the B+Tree data structure to store both collection and index files. Unlike RDBMS, MongoDB offers flexible schemas within its semi-structured BSON format, and JOIN operations are _not necessary_ in MongoDB.
