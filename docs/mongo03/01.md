---
layout: default
title: 3.1. Eviction
parent: 3. Block Manager
nav_order: 1
---
### 3.1. EVITCTION
{: .fs-10 .text-center }

WiredTiger's in-memory cache is implemented in B-tree with hazard pointers, where B-tree nodes are organized in page granularity and cache eviction policy is **LRU**. The block manager is responsible for raw block I/O operations such as read, write, sync, compression and checkpoints. Blocks are managed in a skip list for efficient indexing and allocation.

Eviction in WiredTiger is essential for managing the cache, ensuring it stays within user-defined limits. Eviction is triggered when the cache exceeds these limits, working to bring the cache usage back under control.

## Eviction Process Overview
- **Eviction Structures**: <br>
    Eviction is managed using `WT_EVICT_QUEUE` structures, which contain lists of `WT_EVICT_ENTRY` structures.

- **Eviction Components**: <br>
The eviction process involves one eviction server, zero or more eviction worker threads, and three shared eviction queues (two ordinary queues and one urgent queue).

- **Hazard Pointers**: <br>
Hazard pointers are used to track memory that is still in use. When a page (or piece of data) in the buffer pool is being accessed by a transaction, its address is registered with a hazard pointer. This prevents the page from being evicted while it is still in use, ensuring safe access to the data without corruption or loss. If a page has an associated hazard pointer, it will not be evicted.

## Eviction Server
- **Eviction Server**: <br>
The eviction server is responsible for **finding pages that can be evicted**. It walks through the trees, identifying evictable candidates, and sorts them based on their last access time. The oldest one-third of these candidates (simulating an approximate LRU algorithm) are then added to the eviction queues.

- **Worker Threads**: <br>
Users can configure a minimum and maximum number of eviction worker threads. These threads pop pages from the queues and evict them. The number of worker threads can scale dynamically to optimize eviction performance while minimizing overhead.

- **Urgent Queue**:<br>
Pages marked for forced eviction are placed on the urgent queue, which takes precedence over ordinary eviction queues.

- **Exclusive Access**:<br>
If other threads are reading the content, the page cannot be evicted. The eviction process must lock and gain exclusive access to the page to prevent parallel access during eviction.

## Clean vs. Dirty Data
- **Clean Data**:<br>
Data in the cache that is identical to the version stored on disk.

- **Dirty Data**:<br>
Data in the cache that has been modified and needs to be reconciled with the disk version.

## Clean vs. Dirty Eviction
- **Clean Eviction**:<br>
Involves removing a page from memory that has no dirty content, leaving it unchanged on disk.

- **Dirty Eviction**:<br>
The dirty page undergoes reconciliation, where obsolete content is discarded, the latest values are written to the data store, and older values are moved to the history store.
If a dirty page is selected for eviction, it is first written to a special file, such as the `WiredTigerLAS.wt` file, before being removed from the cache. This ensures that the changes are not lost and can be persisted to disk properly.
